# Py_Crypter - криптер/загрузчик (AES-256)
Заготовка-пример PY-кода "Криптер + Загрузчик" кода на Python (AES-256)

> Недавно пришлось делиться своим мнением о том, как защитить свой код на python от копирования и несанкционированного использования. Поскольку PY-код распространяется в виде открытого текста, то его не проблема просто скопировать, что угодно в нем изменить и т.п. Но как защитить такой код от копирования чужими? Привожу пример такого кода.

Пример использует **TOML** технологию менеджера **UV**. Если **UV** не установлен, то файл "**run_example.bat**" его установит самостоятельно, создаст "**.venv**" и установит в него нужные пакеты **python**. Если не установлен сам **python**, то он будет скачан и установлен автоматически.

1. Клонируйте репозиторий
2. Сделайте текущим его каталог "**py_crypter**"
3. Запустите файл "**run_example.bat**"
4. Далее он все сделает сам - запустит "**py_loader.py**", на его вход подаст файл "**main.cr**" и ключ "**--pass 0123456789**"

**Использование криптера:**

    uv run py_crypter.py file.py file.cr --pass <key>
  
**Использование загрузчика:**

    uv run py_loader.py file.cr --pass <key>

Если --pass опущен, выведется запрос ввода пароля (без эха).

>Думаю не составит труда перевести команду на "чистый" Python, здесь используется UV только для удобства создания venv и загрузки питона, если его нет в системе.

В папке "examples" копии тестовых файлов, как исходника, так и криптованного (см.readme).


Данный пример только показывает алгоритм работы кодера/декодера AES-256 и представляет всего лишь "болванку", используя которую можно дописать свой код до требуемого вам уровня.

Технически — в нашем коде (используя getpass.getpass()) длина пароля практически неограничена, вернее - ограничена только доступной памятью и реальными ограничениями ОС/оболочки. Алгоритмы (PBKDF2) примут любую длину входной строки — итоговый ключ всегда будет фиксированной длины (32 байта для AES-256). Если вводишь пароль через getpass.getpass() (prompt) — ограничение практически только памятью; вводимые строки в терминале обычно поддерживают тысячи символов без проблем. Практически безопасно использовать несколько тысяч символов (например 4096+).

ЕСлм <ключ> с пробелами, то заключить его в кавычки.

Если читать пароль из файла (рекомендуемый способ) — ограничивает только размер файла и память. Можно хранить ключ-файл произвольной длины; для AES-256 нужен именно 32 байта фактического ключа, остальные данные можно использовать как пароль для PBKDF2 или как материал для KDF. PBKDF2 корректно работает с паролями любой длины; длинный пароль лишь немного увеличит время вычисления ключа.

Рекомендации (практические):

1. Лучше не передавать пароль через командную строку.
   Используй getpass() (ввод вручную) или — ещё лучше — файл-ключ key.bin размером ровно 32 байта (os.urandom(32)), с правами 600 (rw-------).

2. Если всё же нужен текстовый пароль для человека:
   — 32–64 случайных символа — более чем достаточно и удобно.
   — Для удобочитаемой, но сильной фразы используй Diceware: 8–10 слов.
   
3. Если требуется конкретное числовое ограничение для планирования:
  — При вводе через getpass() спокойно используйте до 4096 символов; при необходимости — до 32 000 (кроссплатформенный безопасный верх при CLI — ≈32767).
  — Для автоматизированных сценариев используйте файл-ключ (32 байта).

Статья на "Дзен"-е: https://dzen.ru/a/aNl6XEqPjhAqI2p_


